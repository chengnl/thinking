Raft一致性算法分析

# 复制状态机
复制状态机通常是基于复制日志实现，保证所有的服务器执行相同的指令序列，从而保证每个服务器最终产生的结果相同。

一致性算法管理客户端指令的复制日志，状态机从日志中处理相同顺序的相同指令，产生相同的结果。

一致性算法特性：  
*  安全保证：各种网络问题，都可保证正确
*  可用性：超过半数可用；稳定存储可恢复
*  不依赖时序来保证一致性：小部分比较慢节点不会影响系统整理性能。

# Raft一致性算法
通过领导人机制，简化复制日志管理，raft将一致性问题分解成：
*  领导选举：一个新的领导人需要被选举出来，当先存的领导人宕机的时候
*  日志复制：领导人必须从客户端接收日志然后复制到集群中的其他节点，并且强制要求其他节点的日志保持和自己相同。
*  安全性：如果有任何的服务器节点已经应用了一个确定的日志条目到它的状态机中，那么其他服务器节点不能在同一个日志索引位置应用一个不同的指令。

## raft特性
*  选举安全性：对于一个给定的任期号，最多只会有一个领导人被选举出来
*  领导人只附加原则：领导人绝对不会删除或者覆盖自己的日志，只会增加
*  日志匹配原则：如果两个日志在相同的索引位置的日志条目的任期号相同，那么我们就认为这个日志从头到这个索引位置之间全部完全相同
*  领导人完全特性：如果某个日志条目在某个任期号中已经被提交，那么这个条目必然出现在更大任期号的所有领导人中
*  状态机安全特性：如果一个领导人已经在给定的索引值位置的日志条目应用到状态机中，那么其他任何的服务器在这个索引位置不会提交一个不同的日志


## Raft基础
### 状态切换
每个服务器三种状态：领导人、跟随者或者候选人  
![状态图](https://github.com/chengnl/thinking/raw/master/images-folder/raft_state.png)  
服务器状态：跟随者只响应来自其他服务器的请求。如果跟随者接收不到消息，那么他就会变成候选人并发起一次选举。获得集群中大多数选票的候选人将成为领导者。领导人一直都会是领导人直到自己宕机了

### 领导任期
Raft 把时间分割成任意长度的任期
![任期图](https://github.com/chengnl/thinking/raw/master/images-folder/raft_term.png) 
任期用连续的整数标记。每一段任期从一次选举开始，一个或者多个候选人尝试成为领导者。如果一个候选人赢得选举，然后他就在接下来的任期内充当领导人的职责。在某些情况下，一次选举过程会造成选票的瓜分。在这种情况下，这一任期会以没有领导人结束；一个新的任期（和一次新的选举）会很快重新开始。Raft 保证了在一个给定的任期内，最多只有一个领导者。

### 节点远程调用（RPCs）
请求投票（RequestVote） RPCs 由候选人在选举期间发起），然后附加条目（AppendEntries）RPCs 由领导人发起，用来复制日志和提供一种心跳机制。为了在服务器之间传输快照增加了第三种 RPC。当服务器没有及时的收到 RPC 的响应时，会进行重试， 并且他们能够并行的发起 RPCs 来获得最佳的性能。

## 领导选举
Raft 使用一种心跳机制来触发领导人选举。  
当服务器程序启动时，他们都是跟随者身份。一个服务器节点要想继续保持着跟随者状态除非他从领导人或者候选者处接收到有效的 RPCs。领导者周期性的向所有跟随者发送心跳包（不包含日志项内容的附加日志项 RPCs）来维持自己的权威。如果一个跟随者在一段时间里没有接收到任何消息，也就是选举超时，然后他就会认为系统中没有可用的领导者然后开始进行选举以选出新的领导者。

三种状态：
*  自己赢得领导：得到大多数的投票，成为领导，向其他服务发送心跳告知并阻止新领导选举
*  他人赢得领导：收到领导心跳，判断任期，合法变更为跟随者，不合法，继续保持后候选者状态
*  谁也没有成为领导：通过随机选举超时时间的方法保证快速选出领导，减少选票瓜分的情况

## 日志复制
### 日志提交
日志由有序序号标记的条目组成。每个条目都包含创建时的任期号（图中框中的数字），和一个状态机需要执行的指令。一个条目当可以安全的被应用到状态机中去的时候，就认为是可以提交了。  
Raft 算法保证所有已提交的日志条目都是持久化的并且最终会被所有可用的状态机执行。在领导人将创建的日志条目复制到大多数的服务器上的时候，日志条目就会被提交  

![日志提交图](https://github.com/chengnl/thinking/raw/master/images-folder/raft_log_commit.png)


领导人崩溃的情况会使得日志处于不一致的状态，Raft 算法中，领导人处理不一致是通过强制跟随者直接复制自己的日志来解决，跟随者中的冲突的日志条目会被领导人的日志覆盖。
![日志同步图](https://github.com/chengnl/thinking/raw/master/images-folder/raft_log_sync.png)


nextIndex递减检查跟随者日志索引地址条目，nextIndex 会在某个位置使得领导人和跟随者的日志达成一致，当这种情况发生，附加日志 RPC 就会成功，这时就会把跟随者冲突的日志条目全部删除并且加上领导人的日志。一旦附加日志 RPC 成功，那么跟随者的日志就会和领导人保持一致，并且在接下来的任期里一直继续保持。

## 安全性
保证每一个状态机会按照相同的顺序执行相同的指令

### 选举限制
请求投票 RPC 实现了这样的限制： RPC 中包含了候选人的日志信息，然后投票人会拒绝掉那些日志没有自己新的投票请求。  
Raft 通过比较两份日志中最后一条日志条目的索引值和任期号定义谁的日志比较新。如果两份日志最后的条目的任期号不同，那么任期号大的日志更加新。如果两份日志最后的条目任期号相同，那么日志比较长的那个就更加新。

### 提交之前任期内的日志条目
Raft 通过计算副本数目的方式，使得永远不会提交一个之前任期内的日志条目。通过计算副本数目，只有领导人当前任期里的日志条目可以被提交；一旦当前任期的日志条目以这种方式被提交，那么由于日志匹配特性，之前的日志条目也都会被间接的提交。

### 安全性论证
完整性论证：反证法，证明所有比 T 大的领导人一定包含了所有来自 T 的已经被提交的日志

日志完全特性保证拥有更高任期号的领导人会存储相同的日志条目，所以之后的任期里应用某个索引位置的日志条目也会是相同的值。因此，状态机安全特性是成立的。

Raft 要求服务器按照日志中索引位置顺序应用日志条目。和状态机安全特性结合起来看，这就意味着所有的服务器会应用相同的日志序列集到自己的状态机中，并且是按照相同的顺序。

## 跟随者和候选人崩溃
跟随者或者候选人崩溃，Raft无限重试，Raft 的 RPCs 都是幂等的，所以这样重试不会造成任何问题

## 时间和可用性
广播时间（broadcastTime） << 选举超时时间（electionTimeout） << 平均故障间隔时间（MTBF）  
广播时间和平均故障间隔时间是由系统决定的，但是选举超时时间是我们自己选择的。Raft 的 RPCs 需要接收方将信息持久化的保存到稳定存储中去，所以广播时间大约是 0.5 毫秒到 20 毫秒，取决于存储的技术。因此，选举超时时间可能需要在 10 毫秒到 500 毫秒之间。大多数的服务器的平均故障间隔时间都在几个月甚至更长，很容易满足时间的需求。

# 集群成员变化
为了保证安全性，配置更改必须使用两阶段方法，在 Raft 中，集群先切换到一个过渡的配置  
共同一致允许独立的服务器在不影响安全性的前提下，在不同的时间进行配置转换过程。此外，共同一致可以让集群在配置转换的过程人依然响应服务器请求。

重新配置三个问题：
*  第一个问题是，新的服务器可能初始化没有存储任何的日志条目  
   Raft 在配置更新的时候使用了一种额外的阶段，在这个阶段，新的服务器以没有投票权身份加入到集群中来
*  第二个问题是，集群的领导人可能不是新配置的一员    
   在这种情况下，领导人就会在提交了 C-new 日志之后退位（回到跟随者状态）   
*  第三个问题是，移除不在 C-new 中的服务器可能会扰乱集群    
   当服务器确认当前领导人存在时，服务器会忽略请求投票 RPCs。特别的，当服务器在当前最小选举超时时间内收到一个请求投票 RPC，他不会更新当前的任期号或者投出选票

# 日志压缩
![日志压缩](https://github.com/chengnl/thinking/raw/master/images-folder/raft_log_compress.png)  
 Raft 中快照的基础思想。每个服务器独立的创建快照，只包括已经被提交的日志。主要的工作包括将状态机的状态写入到快照中。Raft 也包含一些少量的元数据到快照中：最后被包含索引指的是被快照取代的最后的条目在日志中的索引值（状态机最后应用的日志），最后被包含的任期指的是该条目的任期号。保留这些数据是为了支持快照前的第一个条目的附加日志请求时的一致性检查，因为这个条目需要最后的索引值和任期号。为了支持集群成员更新（第 6 节），快照中也将最后的一次配置作为最后一个条目存下来。一旦服务器完成一次快照，他就可以删除最后索引位置之前的所有日志和快照了。

 在领导人发送快照给跟随者时使用到。领导人总是按顺序发送。