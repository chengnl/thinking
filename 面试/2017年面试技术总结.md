## 分布式架构
### 目前产品架构介绍
  四层，客户端，接入层（预登陆、ap），业务服务层（config和业务服务），数据层（mysql、redis、mq）
  重点介绍每层作用，交互逻辑，如何做到高可用，高扩展，数据库分库分表实现等

  介绍如何保证消息即时（客户端短连，长连实现）、消息不丢失（在线推送和离线游标）

### 目前产品架构思考那些位置可以改进
   逻辑异步，将可以异步的逻辑，考虑异步实现，callback模式或者future模式实现  
   config，使用zookeeper或者etcd，做集群化改造  
   服务调用链追踪  
   服务治理，包括服务监控，服务状态，服务限流，降级等  
   业务抽象整合，比如消息  
   通知中心，集中处理推送  

### 分布式相关知识
   1、分布式事务如何处理
      数据库事务原理>>二阶段提交>>分布式一致性保证>>消息队列保证  
   2、zookeeper和etcd原理  
      zookeeper，zab原子广播协议，根据zxid和myid来确认lead选举算法，半数以上机器投票选举，宕机不超过半数可用。  
      etcd，raft协议，候选者，超时选举选举概念，每个节点随机超时时间，发起选举投票，选择leader，也是半数以上机器投票选举，宕机不超过半数可用。  
   3、产生自增ID方式  
      单机数据库自增>>多机数据库自增，不同步长>>单机数据库，程序按段获取，内存分配（我们的方式）>>雪花片算法（服务器时间之间同步）  
## java知识
### java基础知识
   1、锁  
      sync，可重入锁，分方法，代码块锁，使用cpu指令，方法锁为对象锁，class编译有lock指令，代码块编译两条指令，monitorenter，monitorexit指令  
      sync jvm会优化，运行时有轻量锁（自旋实现），偏向锁（仅相同线程使用锁）之说  
      ReentrantLock，实现原理使用AQS线程队列和自旋实现，通过LockSupport实现线程阻塞和唤醒（park和unpark）
      它的特性，可以实现锁超时控制，线程中断，锁中断，锁申请，锁投票  
      分公平和非公平模式，公平，线程先入队列，等待分配，非公平，先检查锁是否可用，能用即抢占使用，默认为非公平模式  
      ReentrantReadWriteLock，实现原理也是AQS队列，多读少写场景，共享读锁，独占写锁  
      无锁，casc原子变量实现原理，无锁CAS，自旋锁（谈到自适应自旋锁）  
      volidate 线程可见性，java内存模型，volidate变量存储在主存中，非线程cpu缓存中，每次写，立即写入主存，读取的时候发现失效，到主存读取（    
      查看CPU缓存一致性算法，MESI协议）  
      重排规则：happens-before原则  

   2、nio  
      nio reactor模型，单主reactor模型（accept和selectot单线程），主从reactor模型（单线程accept，selector多线程，队列，多线程worker）    
      ，多主reactor模型（单线程accept，多线程accept逻辑认证，其他selector跟主从一样）    
      directbuffer为什么高效，内核级缓存，避免程序层拷贝，普通的heapbytebuffer是字节数组，使用sys.array 来拷贝（引申zero copy）  
      tcp优雅关闭流程，tcp粘包，粘包处理。  
   3、数据结构  
      concurrentmap实现原理（数组、链表、默认16段锁），1.7之前的size实现原理，分段统计，cas比较，二次不同，锁段挨个统计。
      1.8之后（数组、链表、红黑树，红黑树在分组扩展到一定大小的时候，并且链表节点大于8的时候使用，加快查询速度），size只统计分段之和，不做二次操作，锁主要在node节点
      CopyOnWriteArrayList实现原理，sys.array 来数据拷贝

   4、其他
      引用类型：强引用、软引用、弱引用、虚引用
      string（创建string对象，大量追加字符串，占用内存，引起gc）， stringbuffer（线程安全，同步保证），stringbuild（非线程安排，线程内部使用）  
      simpledateformat 非线程安排，每个线程实例应该创建一个对象

### java虚拟机  
   java内存模型  
   新生代、老年段垃圾回收算法，复制，标记清除，标记压缩  
### 手写代码部分
   手写单例模式：4种方式预加载模式，延迟加载模式（线程安排，doublecheck），内部静态类方式，枚举  
   手写快速排序  
   手写实现两个线程交替打印奇偶数  
   手写实现某个目录下，所有非二进制源码文件（包括子目录），统计里面的代码、注释、空行的总数。  
## 性能调优
    1、cpu过高怎么跟踪问题
       top查看 cpu load情况，以及cpu使用率，us用户进程占用，sy系统占用  wa磁盘io等待占用，hi硬中断，si软中断，id空闲

       跟踪程序过高问题，top得过高进程pid
       再找到过高进程，里面线程运行情况，如ps -mp pid -o THREAD,tid，time,得到占用cpu时间比较长的线程ID
       将线程ID转换为十六进制
       打出线程栈，jstack -pid |greo tid -A 150
       得出程序那个位置占用cpu比较高

    2、io过高怎么跟踪问题  
       iostat查看磁盘io占用情况，一般磁盘占用比较高，cpu也会占用高，因为存在等到磁盘io情况，会占用cpu，所以  
       类似cpu过高查问题一样，可以快速查出问题所在。

    3、程序响应慢怎么跟踪分析  
       有日志情况，对日志逐段分析，分析瓶颈
       无日志情况，分析系统资源，cpu ，磁盘io，网络io

    4、jvm优化
       响应优先怎么配置回收算法（parnew，CMS）  吞吐优先怎么配置回收算法（parallel）  
       查看gc日志，jstat -gc   

## 数据库
    1、数据库事务
       表锁、行锁
    2、mysql binlog日志
       三种模式，statement模式（存执行语句，存在函数无法执行问题），row模式（存记录有变化的数据，日志量比较大，比如update），mixed模式  
       （默认设置，混合模式，混合statement和row模式两者优点）
    3、数据库优化
       参数优化，比如配置缓存，连接数，事务处理机制等

## 缓存
    1、缓存主要存那些数据
       用户，在线，企业组织，这三部分数据查询量最多
    2、redis原理
       redis单进程，单线程处理，数据结构有string，map，set，list，zset，zset使用跳表实现，list使用链表实现，数据量大的时候在做分页查询的时候慢  
       redis集群，使用分槽概念，每个节点存储一段hash槽数据，根据crc(key)，找到对应的槽，为了确保每个槽高可用，必须配置从节点  
       即redis集群是多个主从节点构成。
